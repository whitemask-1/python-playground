import numpy as np  # For mathematical operations and arrays
import matplotlib.pyplot as plt  # For plotting
from mpl_toolkits.mplot3d import Axes3D  # For 3D plotting
from matplotlib.animation import FuncAnimation  # For creating animations

#Understand the Mandelbulb fractal:
#The Mandelbulb is a 3D fractal similar to the Mandelbrot set(which is the 2D version).
#It is generated by iterating a point in 3D space through a specific formula (z = z^power + c) in spherical coordinates.
#Points that remain bounded after many iterations are considered part of the Mandelbulb set
#By bounded we mean they do not escape to infinity.
#The classic Mandelbulb uses a power of 8, but other powers can create different shapes.

def mandelbulb(c, max_iter=20, power=5, threshold=2):
    """
    Calculate if a point is in the Mandelbulb set.
    
    The Mandelbulb is a 3D fractal extension of the Mandelbrot set.
    It's generated by iterating a 3D point through a formula in spherical coordinates.
    
    Args:
        c: 3D point coordinates [x, y, z] to test
        max_iter: Maximum number of iterations before considering point as "in the set"
        power: The exponent used in the formula (8 is the classic Mandelbulb)
        threshold: If the distance from origin exceeds this, the point escapes
    
    Returns:
        The iteration count when the point escapes (or max_iter if it doesn't)
    """
    z = np.zeros(3)  # Start with origin point [0, 0, 0]
    
    for i in range(max_iter):
        r = np.linalg.norm(z)  # Calculate distance from origin (magnitude of vector z)
        
        if r > threshold:  # If point escaped the bounded region
            return i  # Return how many iterations it took to escape
        
        # Convert Cartesian coordinates (x, y, z) to spherical coordinates (r, theta, phi)
        # theta: angle from the z-axis (polar angle)
        theta = np.arctan2(np.sqrt(z[0]**2 + z[1]**2), z[2])
        # phi: angle in the xy-plane from the x-axis (azimuthal angle)
        phi = np.arctan2(z[1], z[0])
        
        # Apply the Mandelbulb formula: raise to power in spherical coordinates
        r_pow = r ** power  # Raise the radius to the power
        
        # Convert back to Cartesian coordinates after applying the power
        # This is the core of the Mandelbulb formula
        z = r_pow * np.array([
            np.sin(theta * power) * np.cos(phi * power),  # x component
            np.sin(theta * power) * np.sin(phi * power),  # y component
            np.cos(theta * power)                         # z component
        ]) + c  # Add the original point c (like z = z^power + c)
    
    return max_iter  # Point didn't escape, it's in the Mandelbulb set

# Generate points to test across a 3D grid
resolution = 70  # Increased resolution for more detail (70x70x70 points)
bound = 1.5  # The range to test: from -1.5 to 1.5 in each dimension
points = []  # List to store points that are in the Mandelbulb set

print("Generating Mandelbulb points...")  # Status message

# Loop through all points in a 3D grid
for x in np.linspace(-bound, bound, resolution):  # x values from -1.5 to 1.5
    for y in np.linspace(-bound, bound, resolution):  # y values from -1.5 to 1.5
        for z in np.linspace(-bound, bound, resolution):  # z values from -1.5 to 1.5
            c = np.array([x, y, z])  # Create a 3D point
            
            # Test if this point is in the Mandelbulb set
            # If it returns max_iter (15), it means the point never escaped
            if mandelbulb(c, max_iter=15) == 15:
                points.append(c)  # Add this point to our list

# Convert the list of points to a numpy array for easier manipulation
points = np.array(points)
print(f"Generated {len(points)} points")  # Show how many points were found

# Create the figure and 3D axes for plotting
fig = plt.figure(figsize=(12, 12), facecolor='black')  # Black background for better contrast
ax = fig.add_subplot(111, projection='3d', facecolor='black')  # Black axes background

# Remove the grid and axis panes for a cleaner look
ax.grid(False)  # Turn off grid lines
ax.xaxis.pane.fill = False  # Make x-axis pane transparent
ax.yaxis.pane.fill = False  # Make y-axis pane transparent
ax.zaxis.pane.fill = False  # Make z-axis pane transparent
ax.xaxis.pane.set_edgecolor('none')  # Remove x-axis pane edges
ax.yaxis.pane.set_edgecolor('none')  # Remove y-axis pane edges
ax.zaxis.pane.set_edgecolor('none')  # Remove z-axis pane edges

# Calculate distance from center for each point (for depth-based coloring)
distances = np.linalg.norm(points, axis=1)

def update(frame):
    """
    Update function called for each frame of the animation.
    
    Args:
        frame: The current frame number (used as rotation angle)
    
    Returns:
        The axes object (required by FuncAnimation)
    """
    ax.clear()  # Clear the previous frame
    
    # Reapply black background after clearing
    ax.set_facecolor('black')
    ax.grid(False)
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False
    ax.xaxis.pane.set_edgecolor('none')
    ax.yaxis.pane.set_edgecolor('none')
    ax.zaxis.pane.set_edgecolor('none')
    
    # Set the viewing angle (smooth rotation)
    # elev varies between 15° and 35° for a more dynamic view
    elev = 25 + 10 * np.sin(np.radians(frame))
    ax.view_init(elev=elev, azim=frame)
    
    # Calculate view direction for depth sorting
    # Points further from camera should be drawn first for proper depth perception
    azim_rad = np.radians(frame)
    elev_rad = np.radians(elev)
    view_vector = np.array([
        np.cos(elev_rad) * np.sin(azim_rad),
        np.cos(elev_rad) * np.cos(azim_rad),
        np.sin(elev_rad)
    ])
    
    # Project points onto view direction to get depth
    depths = np.dot(points, view_vector)
    
    # Sort points by depth (back to front)
    sorted_indices = np.argsort(depths)
    sorted_points = points[sorted_indices]
    
    # Plot with larger points and opacity for solid appearance
    ax.scatter(sorted_points[:, 0], sorted_points[:, 1], sorted_points[:, 2],
               c=distances[sorted_indices],  # Color based on distance from center
               cmap='hot',  # Hot colormap (black->red->yellow->white)
               s=3,  # Larger point size for more solid appearance
               alpha=0.8,  # Higher opacity (80%)
               edgecolors='none')  # No edges on points for smoother look
    
    # Set the axis limits
    ax.set_xlim([-bound, bound])
    ax.set_ylim([-bound, bound])
    ax.set_zlim([-bound, bound])
    
    # Hide axis labels and ticks for cleaner appearance
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    
    # Add title with white text
    ax.set_title(f'Mandelbulb Fractal', color='white', fontsize=16, pad=20)
    
    return ax,

# Create the animation with more frames for smoother rotation
anim = FuncAnimation(
    fig,
    update,
    frames=np.arange(0, 3600, 1),  # 0.1° steps for smoother animation (3600 frames)
    interval=33,  # ~30 FPS for fluid motion
    blit=False
)

plt.show()

# To save as high-quality GIF:
# anim.save('mandelbulb.gif', writer='pillow', fps=30, dpi=100)